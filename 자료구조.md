# 1. 배열 (Array)

## 1.1 고정 크기 배열 (Fixed-size Array)
-  **정의**  
    - 고정된 크기를 가지는 연속적인 메모리 공간에 데이터를 저장하는 데이터 구조  
    - 배열은 또한 자료형이 같은 데이터를 순서대로 나열한 뒤 메모리에 연속으로 저장해 만든 자료 그룹  
    - 첫 번쨰 데이터를 기준으로 상대적인 위치를 파악해 나머지 데이터들을 파악  
    ![array](/Users/gwongyeonghyeon/cs정리/source/array.png)

- **특징**  
  - 크기가 고정되어 초기 생성 시 크기를 지정해야 함
  - 데이터 접근 속도가 빠르며, 인덱스를 이용한 O(1) 시간 복잡도로 요소에 접근 가능
  - 데이터 추가/삭제가 비효율적이며, O(n)의 시간 복잡도를 가짐

- **동작 방식**  
  데이터를 연속적으로 메모리에 저장하며, 인덱스를 사용하여 데이터를 참조

- **장단점**  
  - **장점**: 접근 속도가 빠르고 메모리 사용이 효율적
  - **단점**: 크기 변경 불가, 추가/삭제 시 많은 연산 필요

- **활용**  
  고정된 크기의 데이터 처리(예: 월별 매출 데이터)
---
## 1.2 동적 배열 (Dynamic Array)
- **정의 설명**  
  크기를 동적으로 조정할 수 있는 배열 구조

- **특징**  
  - 초기 크기 설정 후 필요 시 크기를 증가시키며 사용
  - 크기 증가 시 새로운 메모리 할당 및 기존 데이터 복사가 필요

- **동작 방식**  
  데이터를 저장하다가 용량을 초과하면 메모리를 재할당하고 데이터를 복사

- **장단점**  
  - **장점**: 크기 변경 가능, 배열처럼 O(1) 접근 속도 유지
  - **단점**: 크기 변경 시 오버헤드 발생

- **활용**  
  데이터 크기가 유동적인 경우(예: 동적 리스트 구현)

---

# 2. 연결 리스트 (Linked List)

## 2.1 단일 연결 리스트 (Singly-Linked List)
- **정의 설명**  
  각 노드가 데이터와 다음 노드의 포인터를 가지는 선형 데이터 구조

- **특징**  
  - 노드들은 메모리 상에 비연속적으로 배치됨
  - 마지막 노드의 포인터는 null을 가리킴

- **동작 방식**  
  노드를 삽입하거나 삭제할 때 연결을 재설정하여 작업 수행

- **장단점**  
  - **장점**: 삽입/삭제가 O(1) 시간 복잡도로 빠름(노드 위치를 알고 있을 때)
  - **단점**: 임의 접근이 불가능하며 탐색 시 O(n) 시간 소요

- **활용**  
  삽입/삭제가 빈번한 데이터 처리(예: 큐, 스택 구현)

---

## 2.2 이중 연결 리스트 (Doubly-Linked List)
- **정의 설명**  
  각 노드가 데이터와 이전/다음 노드의 포인터를 가지는 연결 리스트

- **특징**  
  - 각 노드가 두 개의 포인터(이전, 다음)를 가짐
  - 양방향으로 탐색 가능

- **동작 방식**  
  삽입/삭제 시 이전 및 다음 노드의 포인터를 조정

- **장단점**  
  - **장점**: 양방향 탐색 가능, 삭제 시 단일 연결 리스트보다 효율적
  - **단점**: 포인터 저장을 위한 메모리 추가 소모

- **활용**  
  양방향 이동이 필요한 경우(예: 웹 브라우저 히스토리)

---

## 2.3 원형 연결 리스트 (Circular-Linked List)
- **정의 설명**  
  마지막 노드가 첫 번째 노드를 가리키는 연결 리스트

- **특징**  
  - 단일 또는 이중 연결 리스트 형태로 구현 가능
  - 끝이 없어 순환 구조를 이룸

- **동작 방식**  
  마지막 노드와 첫 번째 노드를 연결하여 삽입/삭제 시 순환 구조 유지

- **장단점**  
  - **장점**: 순환 구조를 활용한 특정 알고리즘 구현 가능
  - **단점**: 순환 구조로 인해 무한 루프에 빠질 가능성, 한 싸이클을 다 돌아야만 특정 노드를 불러낼 수 있음

- **활용**  
  순환 구조가 필요한 시스템(예: 라운드 로빈 스케줄링)

---

## 2.4 다중 연결 리스트 (Multi-Linked List)
- **정의 설명**  
  각 노드가 여러 개의 포인터를 가지는 구조로, 여러 차원의 연결을 표현할 수 있음

- **특징**  
  - 일반적으로 2차원 이상의 데이터를 연결하는 데 사용
  - 노드가 여러 개의 다음 노드에 연결될 수 있음

- **동작 방식**  
  다차원 배열과 유사한 방식으로 각 포인터를 활용하여 데이터를 탐색

- **장단점**  
  - **장점**: 다차원 데이터 표현이 용이
  - **단점**: 포인터 관리가 복잡하며 메모리 사용량 증가

- **활용**  
  그래프 표현, 다차원 배열 구현
---
## 배열vs연결 리스트
| **특징** | **배열 (Array)** | **연결 리스트 (Linked List)**|
|------|-------|-------|
| **메모리 배치** | 연속된 메모리 공간           | 비연속적인 메모리 공간|
| **접근 속도**   | O(1) (인덱스 기반)         | O(n) (순차 탐색)  |
| **크기 조절**   | 고정 또는 동적 (재할당 필요)  | 동적             |
| **삽입/삭제**   | O(n) (중간 요소의 경우)     | O(1) (노드 위치가 알려진 경우)|
| **메모리 효율성** | 높음 (추가 포인터 없음)  | 낮음 (포인터 추가 필요)  |
| **캐시 성능**     | 우수                | 낮음                 |
| **사용 사례**     | 고정 크기 데이터, 인덱스 기반 접근이 빈번한 경우 | 빈번한 삽입/삭제, 동적 크기 조절이 필요한 경우  |

---
# 3. 스택 (Stack)

## 3.1 배열 기반 스택 (Array-based Stack)
- **정의**  
    - 배열을 사용해서 스택의 요소를 저장하는 방식  
    - 스택의 기본 연산인 푸시(push)와 팝(pop)을 배열의 끝에서 수행함

- **특징**  
  - 고정 크기 또는 동적 배열 사용 가능
  - 인덱스를 통해 요소에 접근 가능

- **동작방식**  
  - **푸시(push)**: 배열의 마지막 위치에 요소 추가
  - **팝(pop)**: 배열의 마지막 요소 제거 및 반환
  - **탑(top)**: 배열의 마지막 요소 반환

- **장단점**  
  - **장점**:  
    - 인덱스 접근이 빨라서 O(1) 시간
    - 메모리 사용이 효율적이고 캐시 친화적
  - **단점**:  
    - 고정 크기의 경우 스택 오버플로우 발생 가능
    - 동적 배열일 경우 크기 조정 시 비용 발생

- **활용**  
  - 함수 호출 스택
  - 표현식의 괄호 검사
  - 후위 표기법 계산

---

## 3.2 연결 리스트 기반 스택 (Linked List-based Stack)
- **정의**  
    - 연결 리스트를 사용해서 스택의 요소를 저장하는 방식  
    - 각 노드는 데이터와 다음 노드를 가리키는 포인터로 구성

- **특징**  
  - 동적으로 크기 조절 가능
  - 각 노드가 다음 노드를 가리키는 포인터 포함

- **동작방식**  
  - **푸시(push)**: 새로운 노드를 생성해서 스택의 최상단에 추가
  - **팝(pop)**: 최상단 노드 제거 및 반환
  - **탑(top)**: 최상단 노드의 데이터 반환

- **장단점**  
  - **장점**:  
    - 동적으로 크기 조절 가능해서 스택 오버플로우 발생하지 않음
    - 삽입과 삭제가 O(1) 시간
  - **단점**:  
    - 포인터 때문에 추가 메모리 필요
    - 캐시 성능 저하 가능

- **활용**  
  - 동적으로 크기가 변하는 데이터 처리
  - 함수 호출 스택
  - Undo 기능 구현

---

## 3.3 최소값/최대값 추적 스택 (Min/Max Stack)
- **정의**  
    - 스택 내에서 현재까지의 최소값이나 최대값을 빠르게 조회할 수 있는 기능을 추가한 스택

- **특징**  
  - 최소값이나 최대값을 추적하기 위해 추가적인 스택 사용
  - 요소의 추가 및 제거 시 최소값/최대값도 함께 업데이트

- **동작방식**  
  - **푸시(push)**: 새로운 요소를 메인 스택에 추가하고 최소값/최대값 스택도 업데이트
  - **팝(pop)**: 메인 스택에서 요소 제거하고 최소값/최대값 스택도 함께 업데이트
  - **getMin/getMax**: 최소값/최대값 스택의 최상단 요소 반환

- **장단점**  
  - **장점**:  
    - 최소값이나 최대값을 O(1) 시간에 조회 가능
    - 일반 스택의 모든 기능 유지
  - **단점**:  
    - 추가적인 메모리 필요
    - 구현이 다소 복잡할 수 있음

- **활용**  
  - 실시간으로 최소값이나 최대값을 추적해야 하는 알고리즘
  - 데이터 스트림에서의 동적 분석

---
# 4. 큐 (Queue)

## 4.1 배열 기반 큐 (Array-based Queue)
- **정의**  
    - 배열을 사용해서 큐의 요소를 저장하는 방식  
    - 앞(front)과 뒤(rear)를 관리해서 FIFO 방식으로 요소를 처리

- **특징**  
  - 고정 크기 또는 동적 배열 사용 가능
  - 앞과 뒤의 인덱스를 통해 요소 추가 및 제거

- **동작방식**  
  - **인큐(enqueue)**: 배열의 뒤에 요소 추가
  - **디큐(dequeue)**: 배열의 앞에서 요소 제거 및 반환
  - **프론트(front)**: 큐의 첫 번째 요소 반환
  - **리어(rear)**: 큐의 마지막 요소 반환

- **장단점**  
  - **장점**:  
    - 인덱스 기반 접근으로 요소 추가와 제거가 빠름
    - 메모리 사용이 효율적이고 캐시 친화적
  - **단점**:  
    - 고정 크기의 경우 큐 오버플로우나 언더플로우 발생 가능
    - 동적 배열일 경우 크기 조정 시 비용 발생

- **활용**  
  - 작업 스케줄링
  - BFS 알고리즘
  - 데이터 스트림 처리

---

## 4.2 순환 큐 (Circular Queue)
- **정의**  
    - 배열의 끝과 처음을 연결해서 사용하는 큐 방식  
    - 공간 낭비를 줄이고 배열의 크기를 효율적으로 관리

- **특징**  
  - 원형 구조로 동작
  - 모듈로 연산을 사용해서 인덱스 순환

- **동작방식**  
  - **인큐(enqueue)**: rear 인덱스를 이동시켜 배열의 다음 위치에 요소 추가
  - **디큐(dequeue)**: front 인덱스를 이동시켜 배열의 앞 요소 제거 및 반환
  - **프론트(front)** 및 **리어(rear)**: 현재 앞과 뒤의 요소 반환

- **장단점**  
  - **장점**:  
    - 공간 활용도가 높아서 배열의 공간 낭비 줄임
    - 고정 크기 배열에서도 효율적으로 사용 가능
  - **단점**:  
    - 인덱스 관리가 복잡할 수 있음
    - 여전히 고정 크기의 한계

- **활용**  
  - 링 버퍼
  - 실시간 데이터 스트림 처리
  - 게임의 캐릭터 이동 패턴 관리

---

## 4.3 연결 리스트 기반 큐 (Linked List-based Queue)
- **정의**  
    - 연결 리스트를 사용해서 큐의 요소를 저장하는 방식  
    - 각 노드는 데이터와 다음 노드를 가리키는 포인터로 구성

- **특징**  
  - 동적으로 크기 조절 가능
  - 각 노드가 다음 노드를 가리키는 포인터 포함

- **동작방식**  
  - **인큐(enqueue)**: 새로운 노드를 큐의 뒤에 추가
  - **디큐(dequeue)**: 큐의 앞 노드 제거 및 반환
  - **프론트(front)** 및 **리어(rear)**: 현재 앞과 뒤의 요소 반환

- **장단점**  
  - **장점**:  
    - 동적으로 크기 조절 가능해서 큐 오버플로우 발생하지 않음
    - 삽입과 삭제가 O(1) 시간
  - **단점**:  
    - 포인터 때문에 추가 메모리 필요
    - 캐시 성능 저하 가능

- **활용**  
  - 작업 스케줄링
  - 프린터 작업 관리
  - 네트워크 패킷 버퍼링

---

## 4.4 우선순위 큐 (Priority Queue)
- **정의**  
    - 각 요소에 우선순위를 부여해서 우선순위가 높은 요소가 먼저 처리되는 큐  
    - 동일한 우선순위를 가진 요소는 일반 큐처럼 FIFO 방식으로 처리

- **특징**  
  - 우선순위 기반으로 요소 처리
  - 배열이나 힙을 사용해서 구현 가능

- **동작방식**  
  - **인큐(enqueue)**: 요소를 우선순위에 따라 적절한 위치에 삽입
  - **디큐(dequeue)**: 가장 높은 우선순위를 가진 요소 제거 및 반환
  - **최고 우선순위 요소 조회**: 현재 큐에서 가장 높은 우선순위를 가진 요소 반환

- **장단점**  
  - **장점**:  
    - 우선순위에 따라 효율적으로 요소 처리
    - 다양한 응용 분야에서 유용
  - **단점**:  
    - 구현 방식에 따라 성능 차이 큼
    - 추가적인 메모리 필요할 수 있음

- **활용**  
  - 작업 스케줄링
  - 네트워크 트래픽 관리
  - 다익스트라 알고리즘 같은 최단 경로 탐색

### 4.4.1 배열 기반 우선순위 큐
- **정의**  
    - 배열을 사용해서 우선순위 큐를 구현한 방식  
    - 요소를 배열에 저장하고 우선순위에 따라 정렬

- **특징**  
  - 정렬된 배열 유지
  - 간단하게 구현 가능

- **동작방식**  
  - **인큐(enqueue)**: 요소를 삽입할 위치 찾아 배열에 삽입
  - **디큐(dequeue)**: 배열의 앞이나 뒤에서 가장 높은 우선순위 요소 제거 및 반환

- **장단점**  
  - **장점**:  
    - 구현이 간단하고 이해 쉬움
    - 우선순위가 높은 요소 빠르게 조회 가능
  - **단점**:  
    - 인큐 시 요소의 삽입 위치 찾아 이동시켜야 해서 O(n) 시간
    - 디큐 시 O(1) 또는 O(n) 시간

- **활용**  
  - 간단한 우선순위 기반 작업 처리
  - 교육용 자료 구조 구현

### 4.4.2 힙 기반 우선순위 큐 (Heap-based Priority Queue)
- **정의**  
    - 힙 자료구조를 사용해서 우선순위 큐를 구현한 방식  
    - 보통 이진 힙 사용  
    - 부모 노드가 자식 노드보다 우선순위 높거나 낮은 특성

- **특징**  
  - 힙 속성 유지
  - 효율적인 연산 제공

- **동작방식**  
  - **인큐(enqueue)**: 힙의 마지막 위치에 요소 추가하고 힙 업 연산 통해 힙 속성 유지
  - **디큐(dequeue)**: 힙의 루트 요소 제거하고 마지막 요소 루트로 이동 후 힙 다운 연산 수행
  - **최고 우선순위 요소 조회**: 힙의 루트 요소 반환

- **장단점**  
  - **장점**:  
    - 인큐와 디큐 연산 모두 O(log n) 시간
    - 대규모 데이터에서도 효율적으로 동작
  - **단점**:  
    - 구현이 다소 복잡할 수 있음
    - 힙 외의 요소에 접근 비효율적

- **활용**  
  - 고성능 우선순위 기반 작업 처리
  - 실시간 이벤트 관리
  - 다익스트라나 A* 알고리즘 같은 최단 경로 탐색

---
# 스택 vs 큐

| **구분** | **스택 (Stack)**   | **큐 (Queue)**  |
|------------|-------------|------------------|
| **정의**           | 후입선출(Last-In-First-Out) 방식의 자료구조   | 선입선출(First-In-First-Out) 방식의 자료구조    |
| **주요 연산**      | 푸시(push), 팝(pop), 탑(top)                 | 인큐(enqueue), 디큐(dequeue), 프론트(front), 리어(rear) |
| **크기 조절**      | 고정 또는 동적 크기 조절 가능                 | 고정 또는 동적 크기 조절 가능                 |
| **메모리 배치**    | 배열 또는 연결 리스트 기반으로 구현 가능        | 배열, 연결 리스트, 순환 배열 등으로 구현 가능   |
| **접근 속도**      | 마지막에 추가된 요소에 O(1) 시간 접근 가능      | 처음 추가된 요소에 O(1) 시간 접근 가능          |
| **삽입/삭제**      | 삽입과 삭제가 한쪽 끝에서만 O(1) 시간         | 삽입은 뒤에서, 삭제는 앞에서 O(1) 시간          |
| **메모리 효율성**  | 배열 기반 시 높음, 연결 리스트 시 포인터 추가로 낮음 | 배열 기반 시 높음, 연결 리스트 시 포인터 추가로 낮음 |
| **캐시 성능**      | 배열 기반 시 우수, 연결 리스트 시 낮음           | 배열 기반 시 우수, 연결 리스트 시 낮음           |
| **장점**           | - 구현이 간단하고 효율적<br>- 후입선출 방식 필요 시 적합 | - 데이터의 순차 처리가 필요할 때 유용<br>- 선입선출 방식 필요 시 적합 |
| **단점**           | - 중간 요소에 접근 불가<br>- 순차 접근 불가        | - 중간 요소에 접근 불가<br>- 순차 접근 불가        |
| **활용 사례**      | - 함수 호출 스택<br>- 표현식의 괄호 검사<br>- Undo 기능 | - 작업 스케줄링<br>- BFS 알고리즘<br>- 프린터 작업 관리<br>- 네트워크 패킷 버퍼링 |

---
# 5. 데크 (Deque)

## 5.1 배열 기반 데크 (Array-based Deque)
- **정의**  
    - 배열을 사용해서 데크의 요소를 저장하는 방식  
    - 양쪽 끝에서 요소를 추가하거나 제거할 수 있는 자료구조

- **특징**  
  - 고정 크기 또는 동적 배열 사용 가능
  - 양쪽 끝에서의 삽입과 삭제가 가능함
  - 인덱스를 통해 요소에 접근 가능

- **동작방식**  
  - **앞쪽 인큐(enqueue front)**: 배열의 앞쪽에 요소 추가
  - **뒤쪽 인큐(enqueue rear)**: 배열의 뒤쪽에 요소 추가
  - **앞쪽 디큐(dequeue front)**: 배열의 앞쪽에서 요소 제거 및 반환
  - **뒤쪽 디큐(dequeue rear)**: 배열의 뒤쪽에서 요소 제거 및 반환

- **장단점**  
  - **장점**:  
    - 양쪽 끝에서의 삽입과 삭제가 O(1) 시간에 가능함
    - 배열 기반으로 구현 시 메모리 접근이 빠르고 캐시 친화적임
  - **단점**:  
    - 고정 크기의 경우 공간 낭비 또는 오버플로우 발생 가능
    - 동적 배열일 경우 크기 조정 시 비용 발생
    - 배열의 앞쪽에 요소를 추가할 때 요소를 이동시켜야 할 수 있음

- **활용**  
  - 슬라이딩 윈도우 알고리즘
  - 캐시 구현
  - 브라우저의 앞으로/뒤로 가기 기능

---
## 5.2 연결 리스트 기반 데크 (Linked List-based Deque)
- **정의**  
    - 연결 리스트를 사용해서 데크의 요소를 저장하는 방식  
    - 각 노드는 데이터와 이전 및 다음 노드를 가리키는 포인터를 가짐

- **특징**  
  - 동적으로 크기 조절 가능
  - 양쪽 끝에서의 삽입과 삭제가 용이함
  - 각 노드가 이전 노드와 다음 노드를 가리키는 포인터 포함

- **동작방식**  
  - **앞쪽 인큐(enqueue front)**: 새로운 노드를 연결 리스트의 앞에 추가
  - **뒤쪽 인큐(enqueue rear)**: 새로운 노드를 연결 리스트의 뒤에 추가
  - **앞쪽 디큐(dequeue front)**: 연결 리스트의 앞 노드를 제거 및 반환
  - **뒤쪽 디큐(dequeue rear)**: 연결 리스트의 뒤 노드를 제거 및 반환

- **장단점**  
  - **장점**:  
    - 동적으로 크기 조절 가능해서 공간 낭비 없음
    - 양쪽 끝에서의 삽입과 삭제가 O(1) 시간에 가능함
    - 배열의 앞쪽에 요소를 추가할 때 요소 이동이 필요 없음
  - **단점**:  
    - 포인터를 저장해야 해서 추가 메모리 필요
    - 캐시 성능이 떨어질 수 있음
    - 구현이 배열 기반보다 복잡함

- **활용**  
  - 양방향 큐
  - 브라우저의 앞으로/뒤로 가기 기능
  - 이중 연결 리스트를 이용한 다양한 알고리즘
---
---
# 6. 트리 (Tree)

## 6.1 트리 (Tree)

### 6.1.1 일반 트리 (General Tree)
- **정의**  
    - 트리는 노드와 간선으로 구성된 계층적 데이터 구조  
    - 루트 노드를 기준으로 각 노드가 자식 노드를 가질 수 있음

- **특징**  
  - 노드 간의 관계가 부모-자식 관계로 이루어짐
  - 사이클이 없는 연결 그래프
  - 다양한 형태로 확장 가능 (예: 이진 트리, 다진 트리)

- **동작방식**  
  - 노드의 추가 및 삭제는 부모 노드의 자식 리스트를 수정
  - 루트 노드부터 시작해 자식 노드를 따라 탐색

- **장단점**  
  - **장점**:  
    - 계층적 데이터 표현에 유용  
    - 검색 및 삽입이 효율적일 수 있음  
  - **단점**:  
    - 균형이 맞지 않으면 성능 저하  
    - 구현 복잡성 증가 가능  

- **활용**  
  - 파일 시스템 구조  
  - 조직도  
  - 계층적 데이터 저장

---

### 6.1.2 Left-child-right-sibling 트리 (Left-child-right-sibling Tree)
- **정의**  
    - 일반 트리를 이진 트리로 변환하는 방법  
    - 각 노드는 왼쪽 자식과 오른쪽 형제를 가리키는 포인터를 가짐

- **특징**  
  - 트리의 모든 자식을 왼쪽 자식 포인터와 오른쪽 형제 포인터로 표현
  - 공간 효율성을 높일 수 있음

- **동작방식**  
  - 노드의 자식이 여러 개일 때, 왼쪽 자식 포인터로 첫 자식을 가리키고 오른쪽 형제 포인터로 나머지 자식을 연결
  - 순회 시 형제 노드를 따라가며 탐색

- **장단점**  
  - **장점**:  
    - 일반 트리를 이진 트리의 구조로 표현하여 구현 용이  
    - 공간 효율적  
  - **단점**:  
    - 구조가 복잡해질 수 있음  
    - 특정 트리 연산 시 불편함  

- **활용**  
  - 다양한 트리 구조의 표현  
  - 문서의 계층적 구조 표현

---

## 6.2 트리 순회 (Tree Traversal)

### 6.2.1 전위 순회 (Pre-order Traversal)
- **정의**  
    - 노드를 방문하고, 왼쪽 자식, 오른쪽 자식을 순으로 탐색하는 순회 방식

- **특징**  
  - 루트 노드를 먼저 방문
  - 재귀적 또는 비재귀적으로 구현 가능

- **동작방식**  
  - 현재 노드 방문  
  - 왼쪽 서브트리 전위 순회  
  - 오른쪽 서브트리 전위 순회

- **장단점**  
  - **장점**:  
    - 루트 노드 방문을 우선시  
    - 구조 복원에 유리  
  - **단점**:  
    - 특정 용도에 제한적  

- **활용**  
  - 트리의 구조 복원  
  - 표현식 트리에서 연산 순서 결정

### 6.2.2 중위 순회 (In-order Traversal)
- **정의**  
    - 왼쪽 자식을 방문하고, 현재 노드, 오른쪽 자식을 순으로 탐색하는 순회 방식

- **특징**  
  - 이진 탐색 트리에서 노드를 오름차순으로 방문

- **동작방식**  
  - 왼쪽 서브트리 중위 순회  
  - 현재 노드 방문  
  - 오른쪽 서브트리 중위 순회

- **장단점**  
  - **장점**:  
    - 이진 탐색 트리에서 정렬된 순서로 요소 접근 가능  
  - **단점**:  
    - 일반 트리에서는 특별한 의미 없음  

- **활용**  
  - 이진 탐색 트리의 데이터 정렬  
  - 표현식 트리에서 중위 표현식 생성

### 6.2.3 후위 순회 (Post-order Traversal)
- **정의**  
    - 왼쪽 자식, 오른쪽 자식을 방문하고, 현재 노드를 탐색하는 순회 방식

- **특징**  
  - 루트 노드를 마지막에 방문

- **동작방식**  
  - 왼쪽 서브트리 후위 순회  
  - 오른쪽 서브트리 후위 순회  
  - 현재 노드 방문

- **장단점**  
  - **장점**:  
    - 트리의 하위 구조부터 처리할 때 유리  
  - **단점**:  
    - 특정 용도에 제한적  

- **활용**  
  - 트리의 삭제 작업  
  - 표현식 트리에서 후위 표현식 생성

### 6.2.4 레벨 순회 (Level-order Traversal)
- **정의**  
    - 트리의 레벨별로 노드를 방문하는 순회 방식 (너비 우선 탐색)

- **특징**  
  - 큐를 사용하여 구현

- **동작방식**  
  - 루트 노드 큐에 추가  
  - 큐가 빌 때까지 반복: 큐에서 노드 제거, 방문, 자식 노드 큐에 추가

- **장단점**  
  - **장점**:  
    - 최단 경로 탐색에 유용  
    - 트리의 레벨별 데이터 접근 가능  
  - **단점**:  
    - 공간 복잡도가 높음 (노드 수에 비례)  

- **활용**  
  - 너비 우선 탐색 (BFS) 알고리즘  
  - 레벨별 데이터 처리

---

## 6.3 이진 트리 (Binary Tree)

### 6.3.1 포화 이진 트리 (Full Binary Tree)
- **정의**  
    - 모든 노드가 0개 또는 2개의 자식을 가지는 이진 트리

- **특징**  
  - 모든 레벨이 꽉 차 있음  
  - 균형이 잘 맞아 효율적인 검색 가능

- **동작방식**  
  - 노드의 삽입과 삭제는 부모의 자식 상태에 따라 결정

- **장단점**  
  - **장점**:  
    - 균형이 잘 맞아 검색 및 삽입/삭제 효율적  
  - **단점**:  
    - 모든 노드가 2개의 자식을 가져야 하므로 유연성 부족  

- **활용**  
  - 이진 탐색 트리 구현  
  - 효율적인 데이터 검색

### 6.3.2 완전 이진 트리 (Complete Binary Tree)
- **정의**  
    - 마지막 레벨을 제외한 모든 레벨이 꽉 차 있고, 마지막 레벨의 노드들은 왼쪽부터 채워진 이진 트리

- **특징**  
  - 높이가 최소화됨  
  - 배열으로 효율적으로 구현 가능

- **동작방식**  
  - 노드의 삽입은 항상 왼쪽부터 채워짐  
  - 배열 인덱스를 사용하여 부모-자식 관계 관리

- **장단점**  
  - **장점**:  
    - 메모리 사용이 효율적  
    - 배열 기반 구현 시 빠른 접근 가능  
  - **단점**:  
    - 노드 추가/삭제 시 트리 구조가 약간 제한적  

- **활용**  
  - 힙 구현  
  - 효율적인 데이터 저장 및 검색

### 6.3.3 경사 트리 (Skewed Tree)
- **정의**  
    - 모든 노드가 한쪽 방향으로만 자식을 가지는 이진 트리

- **특징**  
  - 한쪽 방향으로만 치우쳐져 있음  
  - 선형 구조로 비효율적일 수 있음

- **동작방식**  
  - 노드의 삽입과 삭제가 일방향으로만 이루어짐

- **장단점**  
  - **장점**:  
    - 간단한 구현 가능  
  - **단점**:  
    - 최악의 경우 성능이 O(n)으로 비효율적  
    - 트리의 균형이 맞지 않아 검색 속도 저하  

- **활용**  
  - 특정 조건에서의 트리 구조  
  - 간단한 데이터 구조가 필요한 경우

### 6.3.4 수식 트리 (Expression Tree)
- **정의**  
    - 수식의 연산자와 피연산자를 표현하기 위해 사용되는 이진 트리

- **특징**  
  - 내부 노드는 연산자, 리프 노드는 피연산자  
  - 수식의 구조를 트리 형태로 표현

- **동작방식**  
  - 수식을 트리 형태로 구성하여 연산자와 피연산자 간의 관계 표현  
  - 트리 순회를 통해 수식의 계산 가능

- **장단점**  
  - **장점**:  
    - 수식의 구조적 표현 가능  
    - 수식 평가 및 변환이 용이  
  - **단점**:  
    - 복잡한 수식일 경우 트리의 크기 증가  
    - 구현 복잡성  

- **활용**  
  - 컴파일러의 구문 분석  
  - 수식 계산기  
  - 표현식 평가 및 최적화

---

## 6.4 이진 탐색 트리 (Binary Search Tree)

### 6.4.1 균형 이진 탐색 트리 (Balanced BST)

#### 6.4.1.1 AVL 트리 (AVL Tree)
- **정의**  
    - 모든 노드에서 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이가 1 이하인 이진 탐색 트리

- **특징**  
  - 자가 균형 이진 탐색 트리  
  - 삽입과 삭제 시 회전을 통해 균형 유지

- **동작방식**  
  - 노드 삽입/삭제 후 트리의 균형 상태 확인  
  - 불균형 시 회전 연산 수행

- **장단점**  
  - **장점**:  
    - 검색, 삽입, 삭제가 모두 O(log n) 시간  
    - 트리의 균형이 항상 유지됨  
  - **단점**:  
    - 회전 연산 구현 복잡  
    - 삽입/삭제 시 약간의 오버헤드  

- **활용**  
  - 데이터베이스 인덱스  
  - 고속 검색이 필요한 애플리케이션

#### 6.4.1.2 레드-블랙 트리 (Red-Black Tree)
- **정의**  
    - 각 노드가 빨강 또는 검정 색상을 가지며, 특정 규칙을 만족하는 자가 균형 이진 탐색 트리

- **특징**  
  - 균형을 유지하기 위해 색상을 활용  
  - 삽입과 삭제 시 색상 변경과 회전 연산 수행

- **동작방식**  
  - 노드 삽입/삭제 시 색상 규칙 위반 시 재조정  
  - 회전을 통해 균형 유지

- **장단점**  
  - **장점**:  
    - 최악의 경우에도 검색, 삽입, 삭제가 O(log n) 시간  
    - 균형 유지가 비교적 간단  
  - **단점**:  
    - 구현 복잡  
    - AVL 트리에 비해 트리 균형이 덜 엄격함  

- **활용**  
  - 표준 라이브러리의 정렬 자료구조 (예: C++ STL의 std::map, std::set)  
  - 다양한 컴퓨터 과학 알고리즘

#### 6.4.1.3 Splay Tree
- **정의**  
    - 최근에 접근한 노드를 트리의 루트로 이동시키는 자가 균형 이진 탐색 트리

- **특징**  
  - 접근 패턴에 따라 트리의 구조 동적으로 변화  
  - 특정 연산이 빈번한 노드를 루트에 가까이 유지

- **동작방식**  
  - 노드 접근 시 스플레이 연산을 통해 루트로 이동  
  - 스플레이 연산은 회전 연산을 사용

- **장단점**  
  - **장점**:  
    - 자주 접근하는 노드에 대한 높은 접근 속도  
    - 구현이 비교적 간단  
  - **단점**:  
    - 최악의 경우 검색 시간이 O(n) 시간  
    - 균형을 항상 유지하지 않음  

- **활용**  
  - 캐시 시스템  
  - 일부 텍스트 편집기

### 6.4.2 B 트리 계열 (B-tree Family)

#### 6.4.2.1 B 트리 (B-Tree)
- **정의**  
    - 다진 트리의 일종으로, 각 노드가 여러 개의 키와 자식을 가질 수 있는 자가 균형 이진 탐색 트리

- **특징**  
  - 노드의 최소 및 최대 키 개수를 정의  
  - 높은 노드 포화도

- **동작방식**  
  - 노드의 키 수가 초과하면 분할  
  - 노드의 키 수가 부족하면 병합 또는 재분배

- **장단점**  
  - **장점**:  
    - 디스크 기반 데이터 구조에 적합  
    - 검색, 삽입, 삭제가 O(log n) 시간  
  - **단점**:  
    - 구현 복잡  
    - 메모리 사용량 증가  

- **활용**  
  - 데이터베이스 인덱스  
  - 파일 시스템

#### 6.4.2.2 B+ 트리 (B+ Tree)
- **정의**  
    - B 트리의 변형으로, 모든 데이터가 리프 노드에만 저장되고 내부 노드는 인덱스 역할을 하는 트리

- **특징**  
  - 리프 노드가 순차적으로 연결되어 있음  
  - 범위 쿼리에 효율적

- **동작방식**  
  - 내부 노드는 키와 자식 포인터만 가짐  
  - 리프 노드에 데이터 저장 및 링크

- **장단점**  
  - **장점**:  
    - 범위 검색에 효율적  
    - 높은 디스크 접근 효율  
  - **단점**:  
    - 구현 복잡  
    - 더 많은 노드 포인터 필요  

- **활용**  
  - 데이터베이스 인덱스  
  - 파일 시스템

#### 6.4.2.3 B* 트리 (B* Tree)
- **정의**  
    - B 트리의 또 다른 변형으로, 노드 분할 시 더 많은 키를 유지하여 공간 활용을 극대화함

- **특징**  
  - 노드의 포화도가 높음  
  - 분할 시 2/3 노드로 분할

- **동작방식**  
  - 노드가 포화되면 이웃 노드와 키를 공유하여 분할  
  - 재분배를 통해 노드 포화도 유지

- **장단점**  
  - **장점**:  
    - 디스크 접근 횟수 감소  
    - 더 높은 공간 활용도  
  - **단점**:  
    - 구현 복잡  
    - 재분배 과정이 복잡함  

- **활용**  
  - 고성능 데이터베이스 인덱스  
  - 대용량 파일 시스템

---

## 6.5 힙 (Heap)

### 6.5.1 최대 힙 (Max-Heap)
- **정의**  
    - 부모 노드가 자식 노드보다 큰 값을 가지는 힙 구조  
    - 루트 노드는 힙의 최대값을 가짐

- **특징**  
  - 완전 이진 트리의 형태  
  - 배열로 효율적으로 구현 가능

- **동작방식**  
  - **인큐(enqueue)**: 힙의 마지막에 노드 추가 후 힙 업 연산 수행  
  - **디큐(dequeue)**: 루트 노드 제거, 마지막 노드를 루트로 이동, 힙 다운 연산 수행

- **장단점**  
  - **장점**:  
    - 최대값을 O(1) 시간에 접근 가능  
    - 힙 업과 힙 다운 연산이 O(log n) 시간  
  - **단점**:  
    - 특정 노드에 대한 접근이 비효율적  
    - 힙 정렬 외의 용도가 제한적  

- **활용**  
  - 우선순위 큐  
  - 힙 정렬  
  - 실시간 데이터 처리

### 6.5.2 최소 힙 (Min-Heap)
- **정의**  
    - 부모 노드가 자식 노드보다 작은 값을 가지는 힙 구조  
    - 루트 노드는 힙의 최소값을 가짐

- **특징**  
  - 완전 이진 트리의 형태  
  - 배열로 효율적으로 구현 가능

- **동작방식**  
  - **인큐(enqueue)**: 힙의 마지막에 노드 추가 후 힙 업 연산 수행  
  - **디큐(dequeue)**: 루트 노드 제거, 마지막 노드를 루트로 이동, 힙 다운 연산 수행

- **장단점**  
  - **장점**:  
    - 최소값을 O(1) 시간에 접근 가능  
    - 힙 업과 힙 다운 연산이 O(log n) 시간  
  - **단점**:  
    - 특정 노드에 대한 접근이 비효율적  
    - 힙 정렬 외의 용도가 제한적  

- **활용**  
  - 우선순위 큐  
  - 힙 정렬  
  - 실시간 데이터 처리

### 6.5.3 이진 힙 (Binary Heap)
- **정의**  
    - 완전 이진 트리를 기반으로 한 힙 구조  
    - 최대 힙 또는 최소 힙으로 구현

- **특징**  
  - 배열로 효율적으로 구현 가능  
  - 부모와 자식 간의 관계가 인덱스로 관리

- **동작방식**  
  - **인큐(enqueue)**: 배열의 끝에 노드 추가 후 힙 업 연산  
  - **디큐(dequeue)**: 루트 노드 제거, 마지막 노드를 루트로 이동 후 힙 다운 연산

- **장단점**  
  - **장점**:  
    - 구현이 간단하고 효율적  
    - 힙 연산이 O(log n) 시간  
  - **단점**:  
    - 특정 노드에 대한 접근이 비효율적  
    - 동적 우선순위 큐 구현에 제한적  

- **활용**  
  - 우선순위 큐  
  - 힙 정렬  
  - 실시간 데이터 처리

### 6.5.4 피보나치 힙 (Fibonacci Heap)
- **정의**  
    - 여러 개의 트리로 구성된 힙 구조  
    - 트리의 구조가 유연하여 힙 연산이 더욱 효율적

- **특징**  
  - 최소 힙의 특성을 가짐  
  - 삽입, 병합, 감소 키 연산이 O(1) 시간에 가능  
  - 디큐 연산이 O(log n) 시간

- **동작방식**  
  - **인큐(enqueue)**: 새로운 노드 트리에 추가  
  - **디큐(dequeue)**: 최소 노드를 제거하고 트리의 구조 재조정  
  - **감소 키(decrease key)**: 노드의 키 값을 감소시키고 필요한 경우 트리 구조 재조정

- **장단점**  
  - **장점**:  
    - 일부 연산이 매우 빠름  
    - 병합 연산이 O(1) 시간  
  - **단점**:  
    - 구현이 매우 복잡  
    - 높은 상수 오버헤드  

- **활용**  
  - 최단 경로 알고리즘 (예: 다익스트라)  
  - 우선순위 큐 구현  
  - 그래프 알고리즘

### 6.5.5 이진 트리 기반 힙 (Binary Tree-based Heap)
- **정의**  
    - 이진 트리를 기반으로 한 힙 구조  
    - 부모 노드와 자식 노드 간의 관계가 인덱스로 관리

- **특징**  
  - 배열로 효율적으로 구현 가능  
  - 부모와 자식 간의 관계가 단순

- **동작방식**  
  - **인큐(enqueue)**: 힙의 마지막에 노드 추가 후 힙 업 연산  
  - **디큐(dequeue)**: 루트 노드 제거, 마지막 노드를 루트로 이동 후 힙 다운 연산

- **장단점**  
  - **장점**:  
    - 구현이 간단하고 효율적  
    - 힙 연산이 O(log n) 시간  
  - **단점**:  
    - 특정 노드에 대한 접근이 비효율적  
    - 동적 우선순위 큐 구현에 제한적  

- **활용**  
  - 우선순위 큐  
  - 힙 정렬  
  - 실시간 데이터 처리

---

## 6.6 분리 집합 (Disjoint Set)

### 6.6.1 Union-Find 알고리즘 (Union-Find Algorithm)
- **정의**  
    - 서로소 집합을 관리하는 자료구조  
    - 합집합(Union)과 찾기(Find) 연산을 지원

- **특징**  
  - 각 집합을 트리 구조로 표현  
  - 집합 간의 연결 상태를 효율적으로 관리

- **동작방식**  
  - **Find**: 특정 원소가 속한 집합의 대표 원소 찾기  
  - **Union**: 두 집합을 하나의 집합으로 합치기

- **장단점**  
  - **장점**:  
    - 효율적인 집합 관리  
    - 경로 압축과 랭크 병합으로 거의 상수 시간 연산 가능  
  - **단점**:  
    - 초기 구현이 단순하지만 최적화 필요  
    - 메모리 사용량 증가  

- **활용**  
  - 그래프의 최소 신장 트리 알고리즘 (예: Kruskal)  
  - 네트워크 연결 관리  
  - 집합의 분리 상태 관리

### 6.6.2 경로 압축 및 크기 조정 (Path Compression and Union by Rank)
- **정의**  
    - Union-Find 알고리즘의 최적화 기법  
    - 경로 압축은 Find 연산 시 트리의 높이를 줄임  
    - Union by Rank는 Union 연산 시 트리의 높이를 최소화

- **특징**  
  - 트리의 깊이를 최소화하여 연산 속도 향상  
  - 대부분의 연산이 상수 시간에 가깝게 동작

- **동작방식**  
  - **경로 압축**: Find 연산 시 방문한 모든 노드를 루트에 직접 연결  
  - **Union by Rank**: 트리의 높이가 낮은 집합을 높은 집합에 병합

- **장단점**  
  - **장점**:  
    - 매우 빠른 연산 속도  
    - 대규모 집합 관리에 효율적  
  - **단점**:  
    - 구현 복잡도 증가  
    - 추가적인 랭크 정보를 관리해야 함  

- **활용**  
  - Union-Find 알고리즘의 성능 향상  
  - 대규모 네트워크 연결 관리  
  - 효율적인 집합 분할 및 병합

---
# 7. 그래프 (Graph)

## 7.1 그래프 (Graph)

### 7.1.1 방향 그래프 (Directed Graph)
- **정의**  
    - 간선에 방향성이 있는 그래프  
    - 각 간선은 한 노드에서 다른 노드로 향함

- **특징**  
  - 간선의 방향을 고려하여 노드 간의 관계를 표현  
  - 순환이 있을 수 있음

- **동작방식**  
  - 노드 간의 연결을 방향성 있는 간선으로 표시  
  - 인접 리스트나 인접 행렬을 통해 구현

- **장단점**  
  - **장점**:  
    - 복잡한 관계 표현 가능  
    - 경로의 방향을 명확히 할 수 있음  
  - **단점**:  
    - 무방향 그래프에 비해 구현 복잡  
    - 간선의 수가 많아질 경우 메모리 소모 증가

- **활용**  
  - 소셜 네트워크 (팔로우 관계)  
  - 웹 페이지 링크 구조  
  - 작업 의존성 관리

### 7.1.2 무방향 그래프 (Undirected Graph)
- **정의**  
    - 간선에 방향성이 없는 그래프  
    - 간선은 두 노드 간의 상호 연결을 나타냄

- **특징**  
  - 간선은 양방향으로 이동 가능  
  - 간선의 방향을 고려하지 않음

- **동작방식**  
  - 노드 간의 연결을 무방향 간선으로 표시  
  - 인접 리스트나 인접 행렬을 통해 구현

- **장단점**  
  - **장점**:  
    - 구현이 비교적 간단  
    - 간선의 방향을 고려하지 않아 메모리 절약 가능  
  - **단점**:  
    - 방향성을 표현할 수 없음  
    - 특정 관계를 표현하기 어려움

- **활용**  
  - 소셜 네트워크 (친구 관계)  
  - 지리적 지도  
  - 네트워크 연결 구조

### 7.1.3 가중 그래프 (Weighted Graph)
- **정의**  
    - 간선에 가중치(비용, 거리 등)가 부여된 그래프  
    - 각 간선은 연결된 노드 간의 특정 값을 가짐

- **특징**  
  - 가중치를 통해 노드 간의 관계의 강도나 비용 표현  
  - 최단 경로 알고리즘 등에 사용

- **동작방식**  
  - 간선에 가중치 값을 할당  
  - 인접 리스트나 인접 행렬에 가중치 포함하여 저장

- **장단점**  
  - **장점**:  
    - 복잡한 관계의 비용이나 거리를 표현 가능  
    - 다양한 최적화 알고리즘 적용 가능  
  - **단점**:  
    - 무게 정보로 인해 메모리 소모 증가  
    - 구현이 무방향 또는 방향성 그래프에 따라 복잡해질 수 있음

- **활용**  
  - 네비게이션 시스템 (최단 경로 찾기)  
  - 네트워크 라우팅  
  - 게임에서의 이동 비용 계산

### 7.1.4 비가중 그래프 (Unweighted Graph)
- **정의**  
    - 간선에 가중치가 없는 그래프  
    - 모든 간선은 동일한 비용 또는 중요도를 가짐

- **특징**  
  - 간선의 존재만으로 노드 간의 관계를 표현  
  - 최단 경로 알고리즘에서 BFS 사용 가능

- **동작방식**  
  - 간선에 별도의 가중치 정보를 저장하지 않음  
  - 인접 리스트나 인접 행렬에 간선의 존재 여부만 표시

- **장단점**  
  - **장점**:  
    - 구현이 간단  
    - 메모리 사용이 효율적  
  - **단점**:  
    - 간선의 비용이나 중요도를 표현할 수 없음  
    - 최적화된 경로 계산에 한계

- **활용**  
  - 소셜 네트워크 (연결 상태)  
  - 퍼즐 게임의 상태 공간  
  - 네트워크 토폴로지 분석

---
## 7.2 그래프 표현 방식 (Graph Representation)

### 7.2.1 인접 행렬 (Adjacency Matrix)
- **정의**  
    - 그래프의 노드 간의 연결 상태를 2차원 배열로 표현하는 방식  
    - 배열의 행과 열이 그래프의 노드를 나타내고, 각 셀은 간선의 존재 여부나 가중치를 나타냄

- **특징**  
  - 간선 존재 여부를 빠르게 확인 가능  
  - 모든 간선 정보를 명확하게 저장

- **동작방식**  
  - 노드의 개수를 N이라 할 때, N×N 크기의 행렬을 사용  
  - 행렬의 (i, j) 셀에 간선의 존재 여부 또는 가중치 저장

- **장단점**  
  - **장점**:  
    - 간선 존재 여부 확인이 O(1) 시간  
    - 밀집 그래프에 적합  
  - **단점**:  
    - 희소 그래프에서는 메모리 낭비 발생  
    - 간선 목록을 순회하는 데 시간이 많이 소요

- **활용**  
  - 밀집 그래프의 표현  
  - 그래프 알고리즘 구현 시 간선 접근이 빈번한 경우

### 7.2.2 인접 리스트 (Adjacency List)
- **정의**  
    - 그래프의 노드마다 인접한 노드들의 리스트를 저장하는 방식  
    - 각 노드는 자신과 연결된 모든 노드의 리스트를 가짐

- **특징**  
  - 메모리 효율성이 높음  
  - 희소 그래프에 적합

- **동작방식**  
  - 노드마다 연결된 노드들을 리스트나 링크드 리스트로 저장  
  - 각 노드는 자신의 인접 노드들을 참조

- **장단점**  
  - **장점**:  
    - 메모리 사용이 효율적  
    - 간선 목록을 순회하기 용이  
  - **단점**:  
    - 간선 존재 여부 확인이 O(N) 시간  
    - 밀집 그래프에서는 비효율적일 수 있음

- **활용**  
  - 희소 그래프의 표현  
  - 그래프 알고리즘 구현 시 간선 순회가 빈번한 경우

---
## 7.3 그래프 순회 (Graph Traversal)

### 7.3.1 너비 우선 탐색 (Breadth-First Search, BFS)
- **정의**  
    - 그래프의 모든 노드를 레벨별로 탐색하는 알고리즘  
    - 시작 노드에서 가까운 노드부터 방문

- **특징**  
  - 큐를 사용하여 노드를 탐색  
  - 최단 경로를 찾는 데 유용

- **동작방식**  
  - 시작 노드를 큐에 넣고 방문 표시  
  - 큐에서 노드를 하나씩 꺼내어 인접 노드를 큐에 추가하고 방문 표시  
  - 큐가 빌 때까지 반복

- **장단점**  
  - **장점**:  
    - 최단 경로를 보장  
    - 모든 노드를 탐색 가능  
  - **단점**:  
    - 메모리 사용이 큼 (노드 수에 비례)  
    - 깊이가 깊은 그래프에서는 비효율적일 수 있음

- **활용**  
  - 최단 경로 찾기  
  - 네트워크 브로드캐스팅  
  - 소셜 네트워크의 연결성 분석

### 7.3.2 깊이 우선 탐색 (Depth-First Search, DFS)
- **정의**  
    - 그래프의 모든 노드를 가능한 깊이 우선으로 탐색하는 알고리즘  
    - 한 경로를 끝까지 탐색한 후 다른 경로로 이동

- **특징**  
  - 재귀적 또는 스택을 사용하여 구현  
  - 경로의 깊이를 우선적으로 탐색

- **동작방식**  
  - 시작 노드를 방문하고 스택에 추가  
  - 인접한 노드를 방문하고 스택에 추가  
  - 더 이상 방문할 노드가 없으면 스택에서 노드를 제거하고 이전 노드로 돌아감  
  - 모든 노드를 방문할 때까지 반복

- **장단점**  
  - **장점**:  
    - 메모리 사용이 BFS에 비해 적음  
    - 사이클 탐지에 유용  
  - **단점**:  
    - 최단 경로를 보장하지 않음  
    - 깊이가 깊은 그래프에서는 스택 오버플로우 가능

- **활용**  
  - 사이클 탐지  
  - 그래프의 연결성 검사  
  - 경로 찾기 및 미로 탐색

---
## 7.4 최단 경로 알고리즘 (Shortest Path Algorithms)

### 7.4.1 다익스트라 알고리즘 (Dijkstra's Algorithm)
- **정의**  
    - 가중 그래프에서 단일 소스 최단 경로를 찾는 알고리즘  
    - 음수 가중치가 없는 그래프에 사용

- **특징**  
  - 그리디 알고리즘  
  - 우선순위 큐를 사용하여 구현 효율성 향상

- **동작방식**  
  - 시작 노드의 거리를 0으로 설정하고 다른 노드의 거리를 무한대로 설정  
  - 모든 노드를 방문하면서 현재 최소 거리를 가진 노드를 선택  
  - 인접 노드의 거리를 업데이트하고 우선순위 큐에 추가  
  - 모든 노드를 방문할 때까지 반복

- **장단점**  
  - **장점**:  
    - 효율적이고 최단 경로를 보장  
    - 구현이 비교적 간단  
  - **단점**:  
    - 음수 가중치가 있는 그래프에는 적용 불가  
    - 우선순위 큐 구현에 추가적인 메모리 필요

- **활용**  
  - 네비게이션 시스템  
  - 네트워크 라우팅  
  - 게임에서의 최단 경로 찾기

### 7.4.2 벨만-포드 알고리즘 (Bellman-Ford Algorithm)
- **정의**  
    - 가중 그래프에서 단일 소스 최단 경로를 찾는 알고리즘  
    - 음수 가중치를 처리할 수 있으며 음수 사이클을 탐지 가능

- **특징**  
  - 동적 프로그래밍  
  - 간선의 개수에 비례하는 시간 복잡도

- **동작방식**  
  - 시작 노드의 거리를 0으로 설정하고 다른 노드의 거리를 무한대로 설정  
  - 모든 간선을 반복적으로 검사하며 거리를 업데이트  
  - 추가 반복을 통해 음수 사이클을 탐지

- **장단점**  
  - **장점**:  
    - 음수 가중치가 있는 그래프에서도 동작  
    - 음수 사이클 탐지 가능  
  - **단점**:  
    - 시간 복잡도가 높아 대규모 그래프에 비효율적  
    - 최단 경로 보장이 단일 소스에 국한됨

- **활용**  
  - 금융 네트워크에서의 환율 계산  
  - 음수 가중치가 있는 네트워크 라우팅  
  - 그래프의 음수 사이클 탐지

### 7.4.3 플로이드-워셜 알고리즘 (Floyd-Warshall Algorithm)
- **정의**  
    - 모든 쌍 최단 경로를 찾는 알고리즘  
    - 가중 그래프에서 모든 노드 간의 최단 경로를 계산

- **특징**  
  - 동적 프로그래밍  
  - 인접 행렬을 사용하여 구현

- **동작방식**  
  - 모든 노드 쌍의 최단 거리를 초기화  
  - 중간 노드를 하나씩 추가하면서 최단 경로를 업데이트  
  - 최종적으로 모든 노드 쌍의 최단 경로 거리 계산

- **장단점**  
  - **장점**:  
    - 모든 쌍의 최단 경로를 한 번에 계산  
    - 음수 가중치가 있는 그래프에서도 동작 가능 (단, 음수 사이클이 없을 경우)  
  - **단점**:  
    - 시간 복잡도가 O(V³)으로 대규모 그래프에 비효율적  
    - 메모리 사용량이 많음

- **활용**  
  - 네트워크의 모든 쌍 간 최단 경로 계산  
  - 지리적 정보 시스템에서의 경로 분석  
  - 소셜 네트워크 분석

---
## 7.5 최소 신장 트리 (Minimum Spanning Tree)

### 7.5.1 크루스칼 알고리즘 (Kruskal's Algorithm)
- **정의**  
    - 그래프의 모든 노드를 포함하는 최소 신장 트리를 찾는 알고리즘  
    - 간선의 가중치가 낮은 것부터 선택하여 트리를 형성

- **특징**  
  - 그리디 알고리즘  
  - Union-Find 자료구조를 사용하여 사이클 방지

- **동작방식**  
  - 모든 간선을 가중치 순으로 정렬  
  - 가장 낮은 가중치 간선부터 선택  
  - 선택한 간선이 사이클을 형성하지 않으면 신장 트리에 추가  
  - 모든 노드가 연결될 때까지 반복

- **장단점**  
  - **장점**:  
    - 구현이 비교적 간단  
    - 희소 그래프에 적합  
  - **단점**:  
    - 간선 정렬에 시간이 소요됨  
    - 밀집 그래프에서는 비효율적일 수 있음

- **활용**  
  - 네트워크 디자인 (예: 통신 네트워크, 전력망)  
  - 클러스터링 알고리즘  
  - 최소 비용 트리 구축

### 7.5.2 프림 알고리즘 (Prim's Algorithm)
- **정의**  
    - 그래프의 모든 노드를 포함하는 최소 신장 트리를 찾는 알고리즘  
    - 시작 노드에서부터 신장 트리를 확장해 나감

- **특징**  
  - 그리디 알고리즘  
  - 우선순위 큐를 사용하여 구현 효율성 향상

- **동작방식**  
  - 임의의 시작 노드를 선택하고 신장 트리에 추가  
  - 신장 트리에 인접한 간선 중 최소 가중치를 가진 간선을 선택하여 추가  
  - 모든 노드가 신장 트리에 포함될 때까지 반복

- **장단점**  
  - **장점**:  
    - 밀집 그래프에 적합  
    - 구현이 직관적  
  - **단점**:  
    - 간선 탐색 시 시간이 소요될 수 있음  
    - 효율적인 우선순위 큐 구현이 필요

- **활용**  
  - 네트워크 디자인 (예: 통신 네트워크, 전력망)  
  - 최소 비용 트리 구축  
  - 클러스터링 알고리즘

---
## 7.6 위상 정렬 (Topological Sorting)
- **정의**  
    - 방향 그래프의 노드들을 선형 순서로 정렬하는 알고리즘  
    - 모든 간선 (u, v)에 대해 u가 v보다 먼저 오도록 정렬

- **특징**  
  - DAG (Directed Acyclic Graph)에서만 적용 가능  
  - 여러 가지 순서가 가능할 수 있음

- **동작방식**  
  - 진입 차수(indegree)를 계산  
  - 진입 차수가 0인 노드를 큐에 넣고 순서대로 방문  
  - 방문한 노드의 인접 노드들의 진입 차수를 감소시켜 새롭게 진입 차수가 0인 노드를 큐에 추가  
  - 모든 노드를 방문할 때까지 반복

- **장단점**  
  - **장점**:  
    - 작업의 선후 관계를 명확히 할 수 있음  
    - 다양한 응용 분야에서 활용 가능  
  - **단점**:  
    - 사이클이 있는 그래프에서는 적용 불가  
    - 여러 가지 순서가 가능하여 특정 순서를 보장할 수 없음

- **활용**  
  - 작업 스케줄링  
  - 컴파일러의 구문 분석  
  - 프로젝트 관리 (예: 작업 의존성 관리)

---
## 7.7 강결합 요소 탐색 (Strongly Connected Components)

- **정의**  
    - 방향 그래프에서 각 노드 간에 서로 도달 가능한 최대 노드 집합  
    - 모든 노드가 강하게 결합된 집합을 찾는 문제

- **특징**  
  - SCC 알고리즘 (예: Kosaraju, Tarjan) 사용  
  - 그래프의 구조적 특성을 분석

- **동작방식**  
  - Kosaraju 알고리즘: 두 번의 DFS 수행  
  - Tarjan 알고리즘: 단일 DFS를 통해 SCC 식별

- **장단점**  
  - **장점**:  
    - 그래프의 강결합 구조를 명확히 파악  
    - 다양한 그래프 문제에 응용 가능  
  - **단점**:  
    - 구현이 비교적 복잡  
    - 큰 그래프에서는 시간 및 메모리 소모가 클 수 있음

- **활용**  
  - 소셜 네트워크 분석  
  - 컴파일러의 모듈화  
  - 네트워크 분석

---
## 7.8 이분 그래프 탐색 (Bipartite Graph Check)

- **정의**  
    - 그래프가 두 개의 독립적인 집합으로 분할될 수 있는지 확인하는 문제  
    - 각 간선이 서로 다른 집합의 노드들 사이에만 존재해야 함

- **특징**  
  - BFS 또는 DFS를 사용하여 탐색  
  - 그래프의 색칠 문제로도 해석 가능 (2색 문제)

- **동작방식**  
  - 시작 노드에 첫 번째 색을 칠하고 BFS 또는 DFS로 인접 노드에 다른 색을 칠함  
  - 색깔 충돌이 발생하면 이분 그래프가 아님

- **장단점**  
  - **장점**:  
    - 간단한 알고리즘으로 구현 가능  
    - 효율적 (시간 복잡도 O(V + E))  
  - **단점**:  
    - 그래프가 큰 경우 메모리 소모 증가  
    - 비이분 그래프에서는 무의미한 탐색 수행

- **활용**  
  - 작업 배정 문제 (예: 직업과 사람의 매칭)  
  - 네트워크 연결 분석  
  - 자원 배분 문제


